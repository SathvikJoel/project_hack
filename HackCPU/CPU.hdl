/*Designed by : D Hakesh (cs19b017) @ Team 11
CPU.hdl .. Perfomes All logical operations and Arithmetic operations using Hack ALU on 16 Bit numbers.
           Architecture = Von NeuMann Architecture

Input : inM[16] , instruction[16] , reset ;
Output : outM[16],writeM,addressM[15] , pc[15]
(details of input and output are given in CHIP below)

Other Chips included in this Chip(made by team):
1 . HackALU .. HackALU designed by team previously.
(All other chips are inbuilt chips)

Note : 
1 . The CPU is designed for 32K ROM .(length of pc = 15)
*/

CHIP CPU{

    IN  inM[16],instruction[16],reset;    
    //inM[16] = input of M value (memory[A] / RAM[A])
    //instruction[16] = instruction code (A or C instruction)
    //reset = bit to restart current program ie..
    //        if reset = 1 => current programm restarts.Else if 0 ,continues.

    OUT outM[16],writeM,addressM[15],pc[15];          
    //outM[16] = M (Memory) value output
    //WriteM = control signal to write to M (Memory)
    //addressM[15] = address of M (in data Memory)
    //pc[15] = programm counter 

    PARTS:

    //Fetching details of which Instruction (A or C) 
    //Asignal = 1, if instruction[15] = 0(indicates given instruction is A instruction)
    //Csignal = 1, if instruction[15] = 1(indicates given instruction is C instruction)
    Not(in = instruction[15],out = Asignal);
    And(a = true,b = instruction[15],out = Csignal);

    /*************************************** THE A-Register *************************************/

    //We Know that,in C instruction, instruction[5] = d1 
    //indicates A register Destination.
    //Therefore , d1 = instruction[5] & Csignal.
    And(a = instruction[5],b = Csignal,out = d1); 

    /*LOGIC FOR CONTROL SIGNAL OF A-REGISTER */
    //LoadA = control signal for 'A' register
    //Which is true if given instruction is Asignal or d1 = 1
    //Therefore , LoadA = d1 | Asignal.
    Or(a = d1,b = Asignal,out = LoadA);

    /*INPUT DATA FOR A REGISTER*/
    //Data Stored in "A" register is either "A"-instruction or Output from HackALU.
    //inputA = inputA for "A" register
    Mux16(a = instruction, b = out, sel = Csignal, out = inputA);

    /*STORING AT A REGISTER */
    //if LoadA = 1 ,given inputA is stored in "A" register.
    ARegister(in = inputA,load = LoadA,out = A,out[0..14] = addressM);

    /*************************************** THE D-Register *************************************/
    //We know that,In C instruction if d2 = instruction[4] 
    //indicates D register Destination.
    // d2  act as control signal.
    And(a = instruction[4],b = Csignal,out = d2); 
    // input data for D register is from HackALU output,,
    DRegister(in = out,load = d2,out = D);

    /*************************************** writeM signal *************************************/
    //Control sigal for write operation in Data Memory 
    And(a = instruction[3],b = Csignal,out = writeM);

    /*************************************** THE Hack ALU *************************************/
    //NOTE;IF INSTRUCTION IS A INSTRUCTION,HACKALU STILL PERFORMES OPERATION BUT
    //     THOSE RESULTS ARE NOT GOING TO BE USED / STORED .(proper care has been taken)
    //     SO,THERE IS NO PROBLEM IF HACKALU IS ACTIVE EVEN FOR A-INSTRUCTION.
    //     THEREFORE,WE ASSUME INSTRUCTION IS C TO GET INPUTS FOR ALU.

    //One Operand to HackALU is content in D register
    //Other operand is either content at A register or 
    // content of address stored in A register ie..inM
    
    //In C instruction, a = instruction[12] = 1 => M data 
    //                                      = 0 => A register Data.
    Mux16(a = A,b = inM,sel = instruction[12],out = AorMdata); 
    
    //In C instruction,instruntion[6..11] = opcode for HackALU
    /*HACK ALU OPERATION */
    HackALU(x = D,y = AorMdata,zx = instruction[11],nx = instruction[10],zy = instruction[9],ny = instruction[8],f = instruction[7],no = instruction[6],out = out,out = outM,zr = zr,ng = ng);

    /*************************************** THE PROGRAM COUNTER *************************************/
    //We know that , zr = 1 => out = 0 .Similarly notzr = 1 => out != 0
    //               ng = 1 => out < 0 .Similarly notng = 1 => out >= 0
    Not(in = zr,out = notzr);
    Not(in = ng,out = notng);

    /*Jump flags*/

    //if out > 0 => positive = 1
    //positive = (~zr) & (~ng) = notzr & notng
    And(a = notzr,b = notng,out = positive);
    //In C signal , j3 = instruction[0] = 1 indicates
    //whether to "JUMP" PC if ALUout > 0(ie,,positive = 1)
    //jpositive  = jump if out > 0
    And(a = instruction[0],b = positive,out = jpositive);

    //jzero = jump if out = 0 (ie..zr = 1)
    And(a = instruction[1],b = zr,out = jzero);
    //jnegative = 1 ,jump if out < 0 (ie .. ng = 1)
    And(a = instruction[2],b = ng,out = jnegative);

    //Un conditional jump 
    //unCndJmp = j1 & j2 & j3 
    //NOTE : ACTUALLY THIS LOGIC IS NOT REQUIRED TO IMPLEMENT !
    //       AS HACKALU OUPUT IS EITHER >0 OR < 0 OR =0 ALL THE TIME !
    And(a = instruction[0] ,b = instruction[1],out = temp);
    And(a = temp,b = instruction[2],out = unCndJmp);

    /*Jump Signal */
    //jmpSignal = jnegative | jzero | jpositive .
    Or8Way(in[0] = jnegative,in[1] = jzero,in[2] = jpositive,in[3] = unCndJmp,in[4..7] = false,out = jmpSignal);

    //As jump instruction is in C instruction only..
    //jump = jmpsignal & Csignal 
    And(a = jmpSignal,b = Csignal,out = jump);

    /*Program Counter Update */
    //If reset(t-1) then out(t) = 0
    //else if load(t-1) then out(t) = in(t-1)
    //     else if inc(t-1) then out(t) = out(t-1) + 1 (integer addition)
    //          else out(t) = out(t-1)
    //NOTE : since we are using 32K ROM => length of PC = 5 + 10 = 15
    //       But PC out is 16 bit 
    //       So we Truncate MSB of PC 
    PC(in = A,load = jump,inc = true,reset = reset,out[0..14] = pc);
}